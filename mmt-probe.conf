# This is the configuration file for MMT Probe

# the unique identifier given to the probe
probe-id = 3

# folder where the license key exists
license = "/opt/mmt/probe/bin/license.key"

# enable reporting non-ip traffic, such as, ARP, PPP
enable-proto-without-session-report = true
# enable reporting information about fragmentation if IP packets
enable-ip-fragmentation-report = false

#p erform reassembly of TCP segments
enable-tcp-reassembly = true
# perform defragemtation of IP packets 
enable-ip-defragmentation = true

# indicates the period of sampling in seconds, e.g., do statistics each 5 seconds
stats-period = 5

# dynamic configuration from outside of probe, such as, start, stop processing, or update some configurations
dynamic-config {
	enable = true
	## indicate the descriptor of UNIX domain socket to receive control commands,
	descriptor = "/tmp/mmt.sock"
}

input {
	# in case for PCAP the input mode can be ONLINE or OFFLINE, however for DPDK it's only ONLINE
	mode   = OFFLINE
	# input source for PCAP online mode (interface name) and for offline mode (pcap name), 
	#   however for DPDK its interface port number
	source = "../share_box/pcap/smallFlows.pcap"
	# maximal size of a packet
	snap-len = 0        # 0 means default value 65535, apparently what tcpdump uses for -s 0 (only for PCAP)
	
	# option only for DPDK capture
	dpdk-option = "--syslog mmt-probe -c 0xF"
}

# Each kind of report can output to different channel, such as, file, kafak, ...
# General setting of output will be in this block, such as, output format, ...
output {
	# output format: either JSON or CSV (or TLV??)
	format = CSV
	# probe maintains a cache of reports to send them by bulk to channels (file, mongodb, redis, kafka) to improve its execution performace.
	# The cache will be flushed:
	# - when the cache is full
	# - or periodically designed by "cace-period" parameter
	cache-max   = 1000 # number of message in the cache
	
    # number of seconds representing period to flush cache to destination (file, mongodb)
    #in case of file-output, a new file will be created each 5 seconds if file-output.sample-file=true
	cache-period = 5
}

# Indicates outputing report to files
file-output {
    enable = true  # set to false to disable file output, true to enable
    output-file  = "data.csv"      # file name where the reports will be dumped:
    output-dir = "/opt/mmt/probe/result/report/online" # Location where files are written:
    # output-dir = "/media/sf_share_vbox/csv/" # Location where files are written:
	# indicate output to multiple sample files or a single file
	#- if sample-file=true, a new sample file is created each x seconds given by output.cache-period
	sample-file = true
	
	# retains the last x sample files, if sample-file=true
	#- set to 0 to retain all files
	#- note that the value of retain-files must be greater than the value of thread_nb + 1
    retain-files  = 3
}

# indicates REDIS output:
redis-output
{
    enable = false # set to false to disable publishing to REDIS , true to enable
				# publishing to REDIS:
    hostname = "localhost" # hostname of REDIS server
    port = 6379 # port number of REDIS server
    channel = "report" #name of channel to which the messages will be published
}

# indicates KAFKA output:
kafka-output
{
    enable = false # set to false to disable publishing to KAFKA, true to enable
				# publishing to KAFKA:
    hostname = "localhost" # hostname of KAFKA server
    port = 9092 # port number of KAFKA server
    topic = "report" #name of topic to which the message will be published
}

# indicates mongodb output:
mongodb-output {
	enable = false
	hostname = "localhost"
	port = 27017
	database = "mmt-data"
	
	# collection to store reports
	collection = "reports"
	
	# limit size (megabytes - MB = 1000*1000 bytes) of collection
	# - set 0 to unlimit
	# - if the size of collection reaches the limit, the oldest reports will be removed to maintain the limit
	limit-size  = 0
}
 
# socket output
socket-output
{
    enable = false # set to true to enable , false to disable:
    type = BOTH # type of socket domain: either UNIX or INTERNET or BOTH
    descriptor = "/tmp/probe-output.sock" # required for UNIX domain. It is folder location where socket file descriptor is created.
    port = 5000 # Required for Internet domain.
    hostname = "127.0.0.1" # required for Internet domain.
}


# Indicates where the traffic data will be dumped to pcap files
dump-pcap
{
    enable     = false   # set to true/false to enable/disable dumping packet
    # output-dir = "/opt/mmt/probe/" # Location where files will be located
    output-dir = "/tmp/" # Location where files will be located
protocols  = {"unknown"} # List of protocols appearing in a packet which will be dumped
    period     = 0 # New pcap file is created every x seconds. 0 means default value 3600 seconds
    retain-files = 10   # retains the last x sampled files,
	snap-len = 65355 #set snaplength in output pcap files
}


# indicates the threads configuration options
thread-nb    = 0    # this is the number of threads MMT will use for processing packets.
                    # 0: use only one thread to read then process packets
                    # 1: use one thread to process packets, another to read packets
thread-queue = 65256 # 4194304 # 8388608 # 4194304 # this is the maximum number of packets queued for processing that a single thread accepts (only for PCAP).
		    # 0 means MMT decides how many packets to queue (default =1000)
		    # If a packet is dispatched for a thread with a full queue the packet will be dropped and reported in MMT statistics

	

# smp-security
security
{
	enable        = false
	thread-nb     = 1	# the number of security threads per one probe thread , e .g . , if we have 16 probe threads and thread - nb = x ,
				# then x *16 security threads will be used .
				# If set to zero this means that the security analysis will be done in the same threads used by the probe .	
	exclude-rules = "" 	# Range of rules to be excluded from the verification
	rules-mask    = "(1:1,2,9)"	# Mapping of rules to the security threads:
		 	 	 	 	# Format: rules-mask = (thread-index:rule-range);
		 	 	 	 	# thread-index = a number greater than 0
		 	 	 	 	# rule-range = number greater than 0, or a range of numbers greater than 0.
						# Example: If we have thread-nb = 3 and "(1:1 ,2 ,4 -6)(2:3) " ,
						# this means that:
						# thread 1 verifies rules 1 ,2 ,4 ,5 ,6;
						# thread 2 verifies only rule 3; and
						# thread 3 verifies the rest
													
    output-channel = {} # Reports are sent to the output channels . The default value is a file .
			# More than one output channel is possible . In this case , the value should be a set of comma - separated values ; for example: { redis , kafka , file, mongodb, socket }.
			# Reports are sent to output channels only when the global parameters are enable ( file-output.enable = true ,redis-output.enable = true , kafka-output.enable = true, mongodb-output.enable = true)
}

# CPU and memory usage monitor					
system-report
{   enable = false # set to 1 to perform cpu-mem reporting, false to disable it
	period = 5
	output-channel = {} # see security.output-channel for more detailed information
}

# indicates output for behaviour analysis
behaviour
{
    enable  = false  # set to true to enable , false to disable:
    output-dir = "/opt/mmt/probe/result/behaviour/online/"  # Folder to write the output on
}

# Indicates that FTP data reconstruction should be done .
# To enable the reconstruction , also enable the options session-report.enable and session-report.ftp_report.enable
reconstruct-data ftp
{  	
    enable = true
    output-dir  = "/tmp/" # indicates the folder where the output file is created:
	output-channel = {} # see security.output-channel for more detailed information
}

# reconstruct HTTP responses to files
reconstruct-data http
{
     enable = true   
     output-dir = "/tmp/" # location where the files are reconstructed .
     output-channel = {}
}

data-output
{
    include-user-agent = 32 	# Indicates the threshold in terms of data volume for parsing the user agent in Web traffic.
				# The value is in kiloBytes ( kB ) . If the value is zero , this indicates that the parsing of the user agent should be done .
				# To disable the user agent parsing, set the threshold to a negative value (-1).

}

# Specifies the criteria to consider a flow as micro flow.
# - IF a flow has some characters, such as, number of packets/bytes, being less than some litmits,
#   then it will be considered as a micro flow.
# - A micro-flow is identified by protocol ID. This means that a micro-flow represents several flows having
#    + the same protocol ID, and,
#    + number of bytes or packets are less than the thresholds
# - Set value of a limits/threshold to zero to unlimit it
micro-flows
{
    enable = true
    packet-threshold =   1     # packets count threshold to consider a flow as a micro flow:
    byte-threshold   = 100     # data volume threshold to consider a flow as a micro flow:
    
    # a micro-flow will be reported to its output-channel:
    # - at the end of execution of MMT-Probe
	# - or when one of its stats (packets, bytes, flows) is greater than or equal some litmit as specified below.
    report-packet-count  = 100    # packets count threshold to report micro flows aggregated statistics:
    report-byte-count    = 100    # data volume threshold  to report micro flows aggregated statistics:
    report-flow-count    =  10    # limit nb of flows 
       
    output-channel = {} 	# see security.output-channel for more detailed information 
}

# indicates the strategy for RADIUS reporting
radius-report
{
    enable = false
    message-id = 0     # indicates the kind of message one needs to report .
					   # set to 0 to report all messages .
					   # set to a number (from 1 to 255) to indicate the code of message to report, e.g., 1: Access-Request, 2: Access-Accept, 45: CoA-NAK, etc.
    output-channel = {} # see security.output-channel for more detailed information
}


# Specifies the session timeout time, in seconds, for different type of applications
session-timeout
{
    default-session-timeout = 40 # 0 means default value = 60 seconds. For default session:
    long-session-timeout = 0     # 0 means default value = 600 seconds. This is reasonable for Web and SSL connections especially when long polling is used . Usually applications have a long
								 # polling period of about 3~5 minutes .
    short-session-timeout = 0    # 0 means default value = 15 seconds . For short live sessions:
    live-session-timeout  = 0    # 0 means default value = 1500 seconds . For persistent connections like messaging applications and so on: 
}

# indicates session based reporting
session-report
{
    enable = true
	output-channel = {file, mongodb, socket} # see security.output-channel for more detailed information
	
	# enable/disable specific reports for specific protocol applications 
	ftp =  false 
	http = false 
	rtp =  false 
	ssl =  false 
	gtp =  true
}

# Indicates event based reporting: do a report when an event occurs. 
# For example: when MMT-Probe sees a IP packet having IP.SRC, it will report ARP.AR_HLN and IP.SRC. 
# If a packet does not containt an attribute, e.g., ARP.AR_HLN, the attribute's value is replaced by an empty value (either 0 or "").
# We may have multiple "event-report" but its name, e.g., "ip_event", must be unique. 
# For example, event-report http-url{ ...} event-report sample2{ ...}

event-report ip-event
{
    enable = false
    event = "ip.src" # Indicates the event:
    attributes = {"arp.ar_hln", "ip.src", "meta.proto_hierarchy"} # Indicates the list of attributes that are reported when a event is triggered:
    output-channel = {socket} # see security.output-channel for more detailed information
}