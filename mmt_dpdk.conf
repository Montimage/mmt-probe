# This is the configuration file for MMT Probe

# the unique identifier given to the probe
probe-id-number = 3

# in case for PCAP the input mode can be online or offline, however for DPDK its only online
input-mode   = "online"
# folder where the license key exists
license_file_path = "/opt/mmt/probe/bin/license.key"

# indicates the file name where the log messages will be written to
logfile = "/opt/mmt/probe/log/online/log.data"	#default is "log.data" in the running folder

#input source for PCAP online mode (interface name) and for offline mode (pcap name), however for DPDK its interface port number
input-source = "0"

# Indicates where the traffic reports will be dumped ( CSV file )
file-output 
{ 
    enable = 0   # set to zero to disable file output ( CSV ) , 1 to enable 
    data-file   = "dataoutput.csv"      # file name where the reports will be dumped :
    location = "/opt/mmt/probe/result/report/online/" # Location where files are written :
    retain-files  = 10   # retains the last x sampled files, 
    					 # set to 0 to retain all files ( note that the value of retain-files must be greater than the value of thread_nb + 1) :
    sampled_report = 1 # Set to 1 if one needs a sampled file every x seconds or
					   # 0 if one needs a single file :
}

# indicates REDIS output :
redis-output
{
    enabled = 0 # set to 0 to disable publishing to REDIS , 1 to enable
				# publishing to REDIS :
    hostname = "localhost" # hostname of REDIS server :
    port = 6379 # port number of REDIS server :
}

# indicates KAFKA output :
kafka-output
{
    enabled = 0 # set to zero to disable publishing to KAFKA , 1 to enable
				# publishing to KAFKA :
    hostname = "localhost" # hostname of KAFKA server :
    port = 9092 # port number of KAFKA server :
}				

# All the sections below are optional and can be enable or disable according to the requirements.
#thread configuration (default 1 thread), stats-period (default 5 seconds), file-output-period (default 5 seconds)

# indicates the threads configuration options

thread-nb    = 1    # this is the number of threads MMT will use for processing packets. Must be positive.
thread-queue = 3000 # this is the maximum number of packets queued for processing that a single thread accepts (only for PCAP). 
		    # 0 means MMT decides how many packets to queue (default =1000)
		    # If a packet is dispatched for a thread with a full queue the packet will be dropped and reported in MMT statistics
thread-data  = 0    # this is the maximum amount of data queued for processing that a single thread accepts (only for PCAP. 
		    # 0 means unlimited (will always be limited by the system memory)
		    # If a packet is dispatched for a thread with full data the packet will be dropped and reported in MMT statistics
					
snap-len = 0        # 0 means default value 65535, apparently what tcpdump uses for -s 0 (only for PCAP)	


#indicates mmt_security input and output (only with PCAP)
security1 
{       
    enable  = 0   # set to 1 to perform security analysis , 0 to disable it :
    results-dir  = "/opt/mmt/probe/result/security/online/"   # folder where the detected breaches will be reported :
    properties-file  = "test_files/properties_all.xml"  # file containing security properties and rules  
    output-channel = {} # Output reports to the channel, output-channel (string) can be redis, kafka, file. default: redis
                        # More than one output-channel is possible, if so inputs should be comma-separated value for example: {redis, kafka, files)
		        # Output reports are send to channels only when the global parameters are enable (file-output.enable =1, redis-output.enable =1					         
                # kafka-output.enable =1 )	
					
}

#smp-security
security2
{
	enable        = 0	# set to 1 to enable, 0 to disable it
	thread-nb     = 1	# the number of security threads per one probe thread , e .g . , if we have 16 probe threads and thread - nb = x ,
				# then x *16 security threads will be used .
				# If set to zero this means that the security analysis will be done in the same threads used by the probe .	
	exclude-rules = "" 	# Range of rules to be excluded from the verification
	rules-mask    = ""	# Mapping of rules to the security threads:
		 	 	 	 	# Format: rules-mask = (thread-index:rule-range);
		 	 	 	 	# thread-index = a number greater than 0
		 	 	 	 	# rule-range = number greater than 0, or a range of numbers greater than 0.
						# Example : If we have thread-nb = 3 and "(1:1 ,2 ,4 -6)(2:3) " ,
						# this means that :
						# thread 1 verifies rules 1 ,2 ,4 ,5 ,6;
						# thread 2 verifies only rule 3; and
						# thread 3 verifies the rest
													
    output-channel = {} # Reports are sent to the output channels . The default value is a file .
			# More than one output channel is possible . In this case , the value should be a set of comma - separated values ; for example : { redis , kafka , file }.
			# Reports are sent to output channels only when the global parameters are enable ( file-output.enable = 1 ,redis-output.enable = 1 , kafka-output.enable = 1)
}
# CPU and memory usage monitor					
cpu-mem-usage
{   enable = 0 # set to 1 to perform cpu-mem reporting , 0 to disable it :
    frequency = 5 # time-interval for reporting
    output-channel = {} # Reports are sent to the output channels . The default value is a file .
			# More than one output channel is possible . In this case , the value should be a set of comma - separated values ; for example : { redis , kafka , file }.
			# Reports are sent to output channels only when the global parameters are enable ( file-output.enable = 1 ,redis-output.enable = 1 , kafka-output.enable = 1)
}

#indicates behaviour analysis
behaviour
{
    enable  = 0  # set to 1 to enable , 0 to disable :
    location = "/opt/mmt/probe/result/behaviour/online/"  # Folder to write the output :
}

# Indicates that FTP data reconstruction should be done .
# To enable the reconstruction , also enable the options session-report.enable and session-report.ftp_report.enable
reconstruct-ftp
{  	
    enable = 0 # Set to 1 to enable , 0 to disable it :
    location  = "/opt/mmt/" # indicates the folder where the output file is created :
    output-channel = {} # Reports are sent to the output channels . The default value is a file .
			# More than one output channel is possible . In this case , the value should be a set of comma - separated values ; for example : { redis , kafka , file }.
			# Reports are sent to output channels only when the global parameters are enable ( file-output.enable = 1 ,redis-output.enable = 1 , kafka-output.enable = 1)
}

# socket configurations					
socket
{   enable = 0 # set to 1 to enable , 0 to disable :
    domain = 0 # 0 for Unix domain , 1 for Internet domain , and 2 for both :
    socket-descriptor = "/opt/mmt/probe/bin/" # required for UNIX domain . Folder location where socket file descriptor is created :
    port = {5000} # Required for Internet domain . If one-socket-server is set to 0 then the number of port addresses should be
				  # equal to the number of threads ( thread_nb ) . If one-socket-server is set to 1 , the number of port address
				  # should be only one :
    server-address = {"localhost"} # required for Internet domain . IP address of ip_host 1 ,ip_host 2..
    one-socket-server = 1 # If set to 0 the server contains multiple sockets to receive the reports . If set to 1 only one socket will receive the reports :
} 

#This report is for  host1
security-report localhost{
    enable = 0 # set to 1 to enable and 0 to disable :
    # Indicates the list of attributes that are reported when an event is triggered :
    attributes = {"ip.dst","ip.src","http.method"}
}

# This report is for security multi-session security : 
security-report-multisession remote{
    enable = 0 # set to 1 to perform multi-session reporting, 0 to disable it :
    # indicates the list of attributes that are reported :
    attributes = { "nfs.file_name"}
    output-channel = {} # Reports are sent to the output channels . The default value is a file .
			# More than one output channel is possible . In this case , the value should be a set of comma - separated values ; for example : { redis , kafka , file }.
			# Reports are sent to output channels only when the global parameters are enable ( file-output.enable = 1 ,redis-output.enable = 1 , kafka-output.enable = 1)
}


# indicates the strategy for RADIUS reporting
radius-output
{
    enable = 0 		   # set to 1 to enable , 0 to disable :
    include-msg = 0    # indicates the message one needs to report .
					   # set to 0 to report all messages .
					   # set to a number greater than 0 to indicate the message to report (1 for message , 2 for conditions ) :
    include-condition = 0  # indicates the condition to be met in order to report a message .
                       # condition set to 1 indicates that the report should be generated iff the IP to MSISDN mapping is present .
                       # this is the only supported condition for this version . Condition set to 0 to eliminate the condition .
											
    output-channel = {} # Reports are sent to the output channels . The default value is a file .
			# More than one output channel is possible . In this case , the value should be a set of comma - separated values ; for example : { redis , kafka , file }.
			# Reports are sent to output channels only when the global parameters are enable ( file-output.enable = 1 ,redis-output.enable = 1 , kafka-output.enable = 1)
}

data-output
{
    include-user-agent = 32 	# Indicates the threshold in terms of data volume for parsing the user agent in Web traffic.
				# The value is in kiloBytes ( kB ) . If the value is zero , this indicates that the parsing of the user agent should be done .
				# To disable the user agent parsing, set the threshold to a negative value (-1).

}

#Specifies the criteria to consider a flow as micro flow
micro-flows 
{ 
    enable = 0                    # set to 1 to enable , 0 to disable : 
    include-packet-count = 20     # packets count threshold to consider a flow as a micro flow :
    include-byte-count   = 20     # data volume threshold in KB to consider a flow as a micro flow :
    report-packet-count  = 10     # packets count threshold to report micro flows aggregated statistics :
    report-byte-count    = 10     # data volume threshold in KB to report micro flows aggregated statistics :
    report-flow-count    = 5      # Flows count threshold to report micro flows aggregated statistics :    
    output-channel = {} 	  # Reports are sent to the output channels . The default value is a file .
			# More than one output channel is possible . In this case , the value should be a set of comma - separated values ; for example : { redis , kafka , file }.
			# Reports are sent to output channels only when the global parameters are enable ( file-output.enable = 1 ,redis-output.enable = 1 , kafka-output.enable = 1)
}

# Specifies the session timeout time in seconds for different type of applications
session-timeout 
{ 
    default-session-timeout = 40 # 0 means default value = 60 seconds. For default session : 
    long-session-timeout = 0     # 0 means default value = 600 seconds. This is reasonable for Web and SSL connections especially when long polling is used . Usually applications have a long
								 # polling period of about 3~5 minutes .
    short-session-timeout = 0    # 0 means default value = 15 seconds . For short live sessions :
    live-session-timeout  = 0    # 0 means default value = 1500 seconds . For persistent connections like messaging applications and so on :  
}

# indicates event based reporting
event_report report1
{ 
    enable = 0 # set to 1 to enable , 0 to disable :     
    event = "ip.src" # Indicates the event : 
    attributes = {"arp.ar_hln", "ip.src"} # Indicates the list of attributes that are reported when a event is triggered :
    output-channel = {} # Reports are sent to the output channels . The default value is a file .
			# More than one output channel is possible . In this case , the value should be a set of comma - separated values ; for example : { redis , kafka , file }.
			# Reports are sent to output channels only when the global parameters are enable ( file-output.enable = 1 ,redis-output.enable = 1 , kafka-output.enable = 1)
}

# indicates session based reporting
session-report report_session
{ 
    enable = 0 # set to 1 for reporting session reports , 0 to disable :
    output-channel = {} # Reports are sent to the output channels . The default value is a file .
			# More than one output channel is possible . In this case , the value should be a set of comma - separated values ; for example : { redis , kafka , file }.
			# Reports are sent to output channels only when the global parameters are enable ( file-output.enable = 1 ,redis-output.enable = 1 , kafka-output.enable = 1)
}

# indicates condition based reporting and registering handlers from configuration file

condition_report report_web
{
     enable = 0        # reports are sent to output channels only when session report.enable = 1.
					   # set to 1 to enable, 0 to disable : 
     condition = "WEB" # Indicates the condition to be satisfied .  
     # Indicates the list of attributes for reporting .
     attributes = {"http.uri", "http.method", "http.response", "http.content_type", "http.host", "http.user_agent", "http.referer", "http.xcdn_seen", "http.content_len"}
     # Indicates the list of handlers corresponding to the above attributes .
     handlers = {"uri_handle", "http_method_handle", "http_response_handle", "mime_handle", "host_handle", "useragent_handle", "referer_handle", "xcdn_seen_handle", "content_len_handle"}   
}
condition_report report_ftp 
{
     enable = 0         # reports are sent to the output channels only when session-report.enable = 1.
						# set to 1 to enable , 0 to disable :     
     condition = "FTP"  # indicates the condition to be satisfied :
     # indicates the list of attributes for reporting :
     attributes = {"ftp.data_direction", "ftp.p_payload", "ftp.packet_type", "ftp.packet_payload_len", "ftp.data_type", "ftp.file_name", "ftp.packet_request", "ftp.packet_request_parameter", "ftp.packet_response_code", "ftp.packet_reponse_value", "ftp.transfer_type", "ftp.ftp_session_mode", "ftp.file_last_modified", "ftp.session_connection_type", "ftp.user_name", "ftp.password", "ftp.last_command", "ftp.last_response_code", "ftp.file_size", "ftp.control_ip_session_id"}
     # indicates the list of handlers corresponding to the above attributes :
     handlers = {"NULL", "NULL", "NULL", "NULL", "NULL", "NULL", "NULL", "NULL", "NULL", "ftp_response_value_handle", "NULL", "NULL", "NULL", "ftp_session_connection_type_handle", "NULL", "NULL", "NULL", "NULL", "NULL", "NULL"}   

}
condition_report report_rtp
{
     enable = 0        # reports are sent to the output channels only when session-report.enable = 1.
					   # set to 1 to enable , 0 to disable :  
     condition = "RTP" # indicates the condition to be satisfied :   
     # indicates the list of attributes for reporting :
     attributes = {"rtp.version", "rtp.jitter", "rtp.loss", "rtp.order_err", "rtp.burst_loss"}
     # indicates the list of handlers corresponding to the above attributes :
     handlers = {"rtp_version_handle", "rtp_jitter_handle", "rtp_loss_handle", "rtp_order_error_handle", "rtp_burst_loss_handle"}   
}
# set reconstruct_http.enable = 1 and session-report.enable = 1 for http_reconstruction
condition_report reconstruct_http
{
     enable = 0   # Set to 1 for HTTP reconstruction, 0 to disable   
     condition = "HTTP-RECONSTRUCT"      # Indicates the condition.   
     location = "" # location where the files are reconstructed .
     # Indicates the list of attributes .
     attributes = {"tcp.payload_len", "tcp.p_payload", "http.msg_start", "http.header", "http.headers_end", "http.data", "http.msg_end", "http.method", "http.response","http.content_type","http.uri"}
     # Indicates the list of handlers corresponding to the above attributes .
     handlers = {"NULL", "NULL", "http_message_start_handle", "http_generic_header_handle","http_headers_end_handle","http_data_handle","http_message_end_handle","NULL","NULL","NULL","NULL","NULL"}   
}

condition_report report_ssl
{
     enable = 0        # Reports are sent to output channels only when session-report.enable = 1.
					   # Set to 1 to enable , 0 to disable :  
     condition = "SSL" # Indicates the condition to be satisfied :     
     # Indicates the list of attributes for reporting :
     attributes = {"ssl.server_name"}
     # Indicates the list of handlers corresponding to the above attributes :
     handlers = {"ssl_server_name_handle"}   
}

cache-size-for-reporting = 300000  # a value of 0 means that MMT will decide how many packets to cache ( default = 300000) :
enable-proto-without-session-stat = 0 # a value of 1 will enable and 0 will disable the protocol statics :
enable-IP-fragmentation-report = 0 # set to 1 to enable , 0 to disable 
stats-period = 5 # indicates the periodicity for reports :
file-output-period = 5 # indicates the periodicity for reporting output file : 
num-of-report-per-msg = 1 # indicates the number of report per message ( sockets ) .Default is 1. 
                          # this option is only available for MMT-Security using sockets :



