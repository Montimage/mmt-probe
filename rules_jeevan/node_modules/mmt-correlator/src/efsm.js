var redis = require("redis");

MMT = {

  Version: '1.0',
  Types: {
    timestamp: 'timestamp',
    timer: 'timer',
    timeout: 'timeout',
    attribute: 'attribute',
    event: 'event',
    verdict: 'verdict'
  },

  createEFSM: function(efsm) {
    return new MMT.EFSM(efsm);
  },

  tickJSON: function(ts) {
    return {
      v: MMT.Version,
      ts: ts,
      type: MMT.Types.timestamp
    }
  },

  timeoutJSON: function(ts, timeout, id, instance_id) {
    var to = {
      v: MMT.Version,
      ts: ts,
      type: MMT.Types.timeout,
      data: {
        id: id,
        value: timeout
      }
    };
    if(instance_id) to.data.instance_id = instance_id;

    return to;
  },

  addTimerJSON: function(ts, delay, id, instance_id) {
    var timer = {
      v: MMT.Version,
      ts: ts,
      type: MMT.Types.timer,
      data: {
        id: id,
        value: delay,
        isperiodic: false
      }
    };

    if(instance_id) timer.data.instance_id = instance_id;
    return timer;
  },

  addPeriodicTimerJSON: function(ts, delay, id, instance_id) {
    var timer = {
      v: MMT.Version,
      ts: ts,
      type: MMT.Types.timer,
      data: {
        id: id,
        value: delay,
        isperiodic: true
      }
    };

    if(instance_id) timer.data.instance_id = instance_id;
    return timer;
  },

  attributeJSON: function(ts, id, value, attributes, instance_id) {
    var attr = {
      v: MMT.Version,
      ts: ts,
      type: MMT.Types.attribute,
      data: {
        id: id,
        value: value
      },
      attributes: attributes
    };
    if(instance_id) attr.data.instance_id = instance_id;

    return attr;    
  },

  eventJSON: function(ts, id, value, attributes, instance_id) {
    var event = {
      v: MMT.Version,
      ts: ts,
      type: MMT.Types.event,
      data: {
        id: id,
        value: value
      },
      attributes: attributes
    };
    if(instance_id) event.data.instance_id = instance_id;

    return event;
  },

  verdictJSON: function(ts, id, value, attributes, instance_id) {
    var verdict = {
      v: MMT.Version,
      ts: ts,
      type: MMT.Types.verdict,
      data: {
        id: id,
        value: value
      },
      attributes: attributes
    };
    if(instance_id) verdict.data.instance_id = instance_id;

    return verdict;
  },

  publisher: redis.createClient(),

  wipeLog: function (active_state, evt, msg) {
    active_state.wipeLog();
  },

  printLog: function (active_state, evt, msg) {
    console.log('>>>>>>>>>>>>>>> : ' + active_state.state.id);
    console.log(active_state.eventLog);
    console.log('<<<<<<<<<<<<<<< End.');
  },

  startTimer: function (active_state, evt, msg, opts) {
    if(!opts || !opts.timeout || !opts.name) {
        throw new Error('(MMT.startTimer) Parameter error: opts parameter must have timeout and name elements!');  
    }
    MMT.publisher.publish('timeout.add', JSON.stringify(MMT.addTimerJSON(msg.ts, opts.timeout, opts.name, active_state.instance_id)));
  },


  emitEvent: function (active_state, evt, msg, opts) {
    if(!opts || !opts.name) {
        throw new Error('(MMT.emitEvent) Parameter error: opts parameter must have name element!');
    }
    MMT.publisher.publish(opts.name, JSON.stringify(MMT.eventJSON(msg.ts, opts.name, opts.value?opts.value:msg.data.value, opts.attributes?opts.attributes:msg.attributes, msg.data.instance_id)));
  },

  emitVerdict: function (active_state, evt, msg, opts) {
    if(!opts || typeof opts.value === 'undefined') {
        throw new Error('(MMT.emitVerdict) Parameter error: opts parameter must have value element!');
    }
    MMT.publisher.publish(active_state.efsm.id + (opts.property ? '.' + opts.property : '') + '.verdict', JSON.stringify(MMT.verdictJSON(msg.ts, active_state.efsm.id + (opts.property? '.' + opts.property:'') + '.verdict', opts.value, opts.attributes?opts.attributes:msg.attributes, msg.data.instance_id)));
  },

  emitSuccessVerdict: function (active_state, evt, msg, opts) {
    MMT.publisher.publish(active_state.efsm.id + (opts.property ? '.' + opts.property : '') + '.verdict', JSON.stringify(MMT.verdictJSON(msg.ts, active_state.efsm.id + (opts.property? '.' + opts.property:'') + '.verdict', 'Success', opts.attributes?opts.attributes:msg.attributes, msg.data.instance_id)));
  },

  emitFailVerdict: function (active_state, evt, msg, opts) {
    MMT.publisher.publish(active_state.efsm.id + (opts.property ? '.' + opts.property : '') + '.verdict', JSON.stringify(MMT.verdictJSON(msg.ts, active_state.efsm.id + (opts.property? '.' + opts.property:'') + '.verdict', 'Fail', opts.attributes?opts.attributes:msg.attributes, msg.data.instance_id)));
  },

  emitInconclusiveVerdict: function (active_state, evt, msg, opts) {
    MMT.publisher.publish(active_state.efsm.id + (opts.property ? '.' + opts.property : '') + '.verdict', JSON.stringify(MMT.verdictJSON(msg.ts, active_state.efsm.id + (opts.property? '.' + opts.property:'') + '.verdict', 'Inconclusive', opts.attributes?opts.attributes:msg.attributes, msg.data.instance_id)));
  },

}

MMT.Timeout = function(id, start_ts, delay, opts) {
  this.id = id;
  
  this.instance_id = null;
  if(opts.instance_id) this.instance_id = opts.instance_id;

  this.start_ts = start_ts;
  this.expiry_ts = start_ts + delay;
  this.delay = delay;
  this.isperiodic = false;


  if(opts.isperiodic) this.isperiodic = true;
}

//Should be called on periodic timers
MMT.Timeout.prototype.update = function(ts) {
  //Extra check
  if(this.isperiodic) {
    /* TODO: BW: check this out, do we consider the expiry time as the new start time
     * or we consider the time when the expiration was detected as the new start time
     */
    this.start_ts = this.expiry_ts;
    this.expiry_ts = this.start_ts + this.delay;
  }
}

MMT.TimeStore = function(opts) {
  this.sub_tick = redis.createClient();
  this.sub_to = redis.createClient();

  this.pub = redis.createClient();
  this.sub_tick.subscribe('tick');
  this.sub_to.subscribe('timeout.add');
  this.timers = [];
  
  var self = this;

  this.sub_tick.on('message', function (channel, message) {
    try {
      var msg = JSON.parse(message);
      if(msg.ts) self.processTick(msg.ts);
    } catch(err) {
      console.log(err);
    }
  });

  this.sub_to.on('message', function (channel, message) {
    try {
      //msg is expected to have addTimer format
      var msg = JSON.parse(message);
      if(msg.ts && msg.data && msg.data.id && msg.data.value) {
        self.addTimeout(new MMT.Timeout(msg.data.id, msg.ts, msg.data.value /* value in the data part of the msg holds the delay */, {instance_id: msg.data.instance_id}));
      }
    } catch(err) {
      console.log(err);
    }
  });
}

//private function
MMT.TimeStore.prototype.addTimeout = function(to) {
  if(this.timers[to.expiry_ts]) {
    this.timers[to.expiry_ts].push(to);
  }else {
    this.timers[to.expiry_ts] = [to];
  }
}

MMT.TimeStore.prototype.processTick = function(tick_ts) {
  //TODO: This is just a PoC, we can't handle thousands of timers this way
  //for now, we will proceed by ignoring all perf issues :)
  for(var i in this.timers) {
    if(i < tick_ts) {
      for(j in this.timers[i]) {

        this.pub.publish('timeout.' + this.timers[i][j].id, JSON.stringify(MMT.timeoutJSON(tick_ts, this.timers[i][j].expiry_ts, this.timers[i][j].id, this.timers[i][j].instance_id)));

        if(this.timers[i][j].isperiodic) {
          this.timers[i][j].update();
          this.addTimeout(this.timers[i][j]);
        }else {
          delete this.timers[i][j]; 
        }
      }

      this.timers[i] = [];
      delete this.timers[i];
    }
  }
}

/*
{
  id: 'unique_id',
  hascontext: true/false,
  events: ['evt1', 'evt2', 'evt3'],
  states: ['init', 's1', 's2', 's3', 's4'],
  transitions: [
    {
      from: 'init',
      to: 's1',
      event: 'evt1',
      actions: [startTimeout, sendEvent],
      conditions: [checkValue],
    },
  ]
}
*/

MMT.EFSM = function(opts) {
  if(!opts.id) throw Error('(MMT.EFSM) Missing required id parameter!');
  this.id = opts.id;
  this.states = [];
  this.events = [];
  this.transitions = [[]];

  this.active_states = [];

  this.hascontext = false;
  this.logdata = false;
  if(opts.hascontext) this.hascontext = true;
  if(opts.logdata) this.logdata = true;

  this.onCreation = null;
  this.onDeletion = null;

  if(opts.onCreation) this.onCreation = opts.onCreation;
  if(opts.onDeletion) this.onDeletion = opts.onDeletion;

  var self = this;

  for(var s in opts.states) {
    var stt = new MMT.EFSM.State(this, opts.states[s]);
    this.states[stt.id] = stt;
    this.transitions[stt.id] = [];
  }

  for(var e in opts.events) {
    var evt = new MMT.EFSM.Event(this, opts.events[e]);
    this.events[evt.id] = evt;
    for(var s in this.states) {
      this.transitions[this.states[s].id][evt.id] = [];
    }
  }

  for(var t in opts.transitions) {
    this.validateTransition(opts.transitions[t]);
  }

  //Now listen to the corresponding events
  for(var e in this.events) {
    var ev = this.events[e];
    ev.sub.subscribe(ev.id);
    ev.sub.on('message', function (channel, message) {
      try {
        var msg = JSON.parse(message);
        if(msg) self.processEvent(channel, msg);
      } catch(err) {
        console.log(err);
      }
    });
  }
}

MMT.EFSM.prototype.processEvent = function(ev, msg) {
  var active_state = this.getActiveState(msg.data.instance_id);
  
  if(active_state) {
    var trans = this.transitions[active_state.state.id][ev];
    for (t in trans) {
      if(active_state.validateConditions(ev, msg, trans[t])) {
        active_state.transit(ev, msg, trans[t]);
        break;
      }
    }
  }
}

MMT.EFSM.prototype.validateTransition = function(transition) {
  if(!this.states[transition.from] || !this.states[transition.to] || !this.events[transition.event]) {
    throw new Error('Unkown state or event in transition description!');
  }

  var tran = new MMT.EFSM.Transition(this, this.states[transition.from], this.states[transition.to], this.events[transition.event],
    {conditions: transition.conditions, actions: transition.actions});

  this.transitions[tran.from.id][tran.event.id].push(tran);
}

MMT.EFSM.prototype.getActiveState = function(instance_id) {
  if(this.hascontext) {
    if(!instance_id) return null;//TODO: What should we do here???
    if(this.active_states[instance_id]) {
      return this.active_states[instance_id];
    } else {
      var init_state = new MMT.EFSM.ActiveState(this, this.states['init'], {instance_id: instance_id});
      this.active_states[instance_id] = init_state;
      return init_state;
    }
  }else {
    if(this.active_states[0]) { //no context, we can have just one active state
      return this.active_states[0];
    }else {
      var init_state = new MMT.EFSM.ActiveState(this, this.states['init'], {});
      this.active_states[0] = init_state;
      return init_state;
    }
  }
}

MMT.EFSM.Event = function(efsm, id) {
  this.sub = redis.createClient();
  this.id = id;
  this.efsm = efsm;
}

MMT.EFSM.State = function(efsm, opts) {
  this.efsm = efsm;
  this.id = opts.id;
  this.onStepIn = null;
  this.onStepOut = null;

  if(opts.onStepIn) this.onStepIn = opts.onStepIn;
  if(opts.onStepOut) this.onStepOut = opts.onStepOut;
}

MMT.EFSM.ActiveState = function(efsm, state, opts) {
  this.efsm = efsm;
  this.state = state;
  this.instance_id = null;
  if(opts.instance_id) this.instance_id = opts.instance_id;

  this.eventLog = [];
}

MMT.EFSM.ActiveState.prototype.transit = function(ev, msg, transition) {
  if(this.validateConditions(ev, msg, transition)) {
    //The transition will take place as its conditions are met
    
    //If we are changing state apply on StepOut and onStepIn if they exit
    if(transition.from.id !== transition.to.id) {
      //Apply onStepOut from current state if it exists
      if(transition.from.onStepOut) transition.from.onStepOut(this, ev, msg);
      //Apply onStepIn from the new state we are stepping in
      if(transition.to.onStepIn) transition.to.onStepIn(this, ev, msg);

      //Change the current state now
      this.state = transition.to;
    }
    
    if(this.efsm.logdata) {
      this.eventLog.push({event: ev, msg: msg});
    }
    this.applyActions(ev, msg, transition);
  }
}

MMT.EFSM.ActiveState.prototype.validateConditions = function(ev, msg, transition) {
  for(var c in transition.conditions) {
    //TODO: we should assume that the function might not be safe, use try catch here!
    if(transition.conditions[c].fct(this, ev, msg, transition.conditions[c].opts) !== true) return false
  }
  return true;
}

MMT.EFSM.ActiveState.prototype.applyActions = function(ev, msg, transition) {
  for(var a in transition.actions) {
    //TODO: try catch the function
    transition.actions[a].fct(this, ev, msg, transition.actions[a].opts);
  }
}

MMT.EFSM.ActiveState.prototype.wipeLog = function() {
  this.eventLog = [];
}

MMT.EFSM.Transition = function(efsm, from, to, event, opts) {
  this.efsm = efsm;
  this.from = from;
  this.to = to;
  this.event = event;

  this.actions = [];
  this.conditions = [];
  if(opts.actions) this.actions = opts.actions;
  if(opts.conditions) this.conditions = opts.conditions;
}

var timestore = new MMT.TimeStore();

module.exports = MMT;
////////////////////////////////////////////////////////
